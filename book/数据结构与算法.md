# 数据结构与算法

> 数据结构和算法是一个程序员的基础技能，现在我们就从头梳理一下相关的数据结构与算法的知识。

## 目录

1. [数组](#数组)
2. [链表](#链表)
3. [栈](#栈)
4. [队列](#队列)
5. [递归](#递归)
6. [排序](#排序)
7. [二分查找](#二分查找)
8. [散列表](#散列表)
9. [哈希算法](#哈希算法)
10. [树](#树)
    1. [二叉树](#二叉树)
    2. [二叉搜索树](#二叉搜索树)

## 数组

数组是一种非常基础的数据结构，基本上每一种编程语言都会有数组类型。

数组是一种线性表（数据的关系只有前后关系），它使用一组连续的内存来存储数据，正由于这个特性，它才拥有随机访问的特性，但是也是由于这个特点，数组的插入和删除就需要做大量的数据搬移工作。

数组具有随机访问的特性，它的时间复杂度为 O(1)，那么为什么我们要说它删除和插入很低效呢？上面我们说过，数组使用的是一组连续的内存，那我们删除元素过后，要保持数组的特性，就需要将删除元素之后的元素往前搬，同理，在数组中插入一个元素也需要将元素进行搬移。

一种特殊的情况下，我们删除元素的时候，不去真正的删除，而是进行标记，当数组没有更多空间进行存储的时候再将标记已删除的元素进行删除（这是 JVM 的标记清除垃圾回收的思想）。

## 链表



## 树

树是一种非线性表结构，树也是数据结构中非常重要且常用的结构之一，关于一些概念性的问题可以自己去了解一下[百度百科](https://baike.baidu.com/item/%E6%A0%91/2699484?fr=aladdin)。

树的结构是多样化的，接下来我们就学习一下常用的一些树结构。

### 二叉树

二叉树，顾名思义，每个节点最多有两个叉，也就是说最多两个子节点，但是并不要求每个节点都有两个子节点，可以只有左子节点，或者是右子节点等等。

那么有几种特殊情况是什么呢？

1. 满二叉树：这种情况是叶子节点全在最底层，除了叶子节点，每个节点都拥有左右两个子节点。
2. 完全二叉树：除了最后一层，每一层的节点都要达到最大，并且最后一层的叶子节点都要靠左。

下面我们要提出一个问题了，我们怎么存储树这种结构呢？

大家可能想到了，这种链式结构我们用链表就能够实现，大多数树结构也是这么存储的。

那么我们能够通过数组来对二叉树进行存储么？当然能了，比如说，我们将根节点存在索引为 `i = 1` 的位置，那么左节点存在 `2 * i = 2` 的位置，右子节点存在 `2 * i + 1 = 3` 的位置，以此类推就能够存储下二叉树了，但是不知道大家注意到没有，如果我们的二叉树不是上面定义的完全二叉树的形式，那么我们存储的数组就变成了一个稀疏数组。所以说，如果一棵树是完全二叉树，那么数组毫无疑问就是最节省内存的一种方式了。

#### 二叉树的遍历

1. 前序遍历：对于前序遍历而言，是遍历当前节点，再遍历左子树，最后遍历右子树。
2. 中序遍历：对于中序遍历而言，是遍历左子树，再遍历本身，再遍历右子树。
3. 后序遍历：对于后序遍历来说，是先遍历左子树，然后再遍历右子树，最后遍历本身。

那么对于这三种遍历方式如何书写代码呢？

```js
// 前序遍历
preOrder(tree) = print(tree.node) -> preOrder(tree.left) -> preOrder(tree.right)

function preOrder(tree) {
  if (tree === null) return;
  console.log(tree.node);
  preOrder(tree.left);
  preOrder(tree.right);
}
// 中序遍历
midOrder(tree) = midOrder(tree.left) -> print(tree.node) -> midOrder(tree.right)

function midOrder(tree) {
  if (tree === null) return;
  midOrder(tree.left);
  console.log(tree.node);
  midOrder(tree.right);
}
// 后序遍历
afterOrder(tree) = afterOrder(tree.left) -> afterOrder(tree.right) -> print(tree.node)

function afterOrder(tree) {
  if (tree === null) return;
  afterOrder(tree.left);
  afterOrder(tree.right);
  console.log(tree.node);
}
```

当然了，其实还有一种遍历方法，也就是按层遍历，这种遍历需要借助队列来进行实现。

```js
// 层遍历
function levelOrder(tree) {
  if (tree === null) return;

  const queue = [];
  queue.push(tree);
  while(queue.length !== 0) {
    const node = queue.shift();
    console.log(node.value);
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }
}
```

## 二叉搜索树

